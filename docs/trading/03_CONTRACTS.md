# Trading/VOL Harvesting v2 — Data Contracts (SSOT)

**Status:** Draft
**Date:** 2026-01-29
**Schema Version:** `1.0.0`

This document defines canonical schemas for v2 Trading/VOL Harvesting contracts. All contracts are JSON-serializable and must be versioned.

---

## 1) Global Invariants (Hard)

### 1.1 Type Requirements

| Requirement | Rule | Rationale |
|-------------|------|-----------|
| Money/Qty types | `Decimal` (Python) or string in JSON | Float precision loss is unacceptable for trading |
| JSON parsing | String → `Decimal` on parse | Never parse money as float |
| Timestamps | `int` (milliseconds since epoch) | Consistent with v1 contracts |
| Enums | String literals | Explicit, readable, version-safe |

### 1.2 Required Fields (All Contracts)

Every v2 contract MUST include:

| Field | Type | Description |
|-------|------|-------------|
| `schema_version` | `str` | Contract version (e.g., `"1.0.0"`) |
| `session_id` | `str` | Trading session identifier (UUID or date-based) |

### 1.3 Idempotency & Dedupe Keys

| Contract | Dedupe Key | Notes |
|----------|------------|-------|
| `OrderIntent` | `(session_id, client_order_id)` | Client-generated ID |
| `OrderAck` | `(session_id, order_id)` | Exchange-assigned ID |
| `FillEvent` | `(symbol, order_id, trade_id)` | **Critical**: dedupe on this tuple |
| `PositionSnapshot` | `(session_id, symbol, ts)` | Point-in-time snapshot |
| `SessionState` | `(session_id, ts)` | State machine checkpoint |
| `RiskBreachEvent` | `(session_id, breach_id)` | Unique breach identifier |

### 1.4 Unit Conventions

| Quantity | Unit | Example |
|----------|------|---------|
| NATR | Fraction | `0.025` = 2.5% |
| Fees | Fraction | `0.0002` = 0.02% = 2 bps |
| Prices | Decimal string | `"67890.50"` |
| Quantities | Decimal string | `"0.001"` |
| PnL | Decimal string (USD) | `"-12.50"` |

---

## 2) OrderIntent

**Purpose:** Request to place an order, generated by trading logic.
**Producer:** VolHarvester / OrderManager
**Consumer:** OrderGovernor → Binance REST

### Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `schema_version` | `str` | Yes | `"1.0.0"` |
| `session_id` | `str` | Yes | Trading session ID |
| `ts` | `int` | Yes | Intent creation timestamp (ms) |
| `client_order_id` | `str` | Yes | Unique client-side ID (UUID) |
| `symbol` | `str` | Yes | Trading pair (e.g., `"BTCUSDT"`) |
| `side` | `str` | Yes | `"BUY"` or `"SELL"` |
| `order_type` | `str` | Yes | `"LIMIT"`, `"MARKET"`, `"STOP_MARKET"` |
| `quantity` | `str` | Yes | Order size (Decimal as string) |
| `price` | `str` | Conditional | Limit price (required for LIMIT orders) |
| `time_in_force` | `str` | Yes | `"GTC"`, `"IOC"`, `"FOK"`, `"GTX"` |
| `reduce_only` | `bool` | Yes | If true, only reduces position |
| `priority` | `str` | Yes | `"NORMAL"`, `"KILL"`, `"EMERGENCY"` |
| `reason` | `str` | No | Human-readable intent reason |

### Enums

```
side: "BUY" | "SELL"
order_type: "LIMIT" | "MARKET" | "STOP_MARKET"
time_in_force: "GTC" | "IOC" | "FOK" | "GTX"
priority: "NORMAL" | "KILL" | "EMERGENCY"
```

### JSON Example

```json
{
  "schema_version": "1.0.0",
  "session_id": "sess_20260129_001",
  "ts": 1738180800000,
  "client_order_id": "coid_a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "symbol": "BTCUSDT",
  "side": "BUY",
  "order_type": "LIMIT",
  "quantity": "0.001",
  "price": "67890.50",
  "time_in_force": "GTX",
  "reduce_only": false,
  "priority": "NORMAL",
  "reason": "vol_harvest_entry_level_1"
}
```

> **Note:** JSON examples must match `model_dump_json()` output from Pydantic models.

---

## 3) OrderAck

**Purpose:** Acknowledgement from exchange after order submission.
**Producer:** OrderGovernor (from Binance REST response)
**Consumer:** OrderManager, Journal, Reconciler

### Design Decision: Canonical vs Raw

**Resolution:** `OrderAck` is the **canonical** contract using Decimal types. If raw exchange response storage is needed, use a separate `RawOrderResponse` object (not specified here) that is never used in business logic.

### Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `schema_version` | `str` | Yes | `"1.0.0"` |
| `session_id` | `str` | Yes | Trading session ID |
| `ts` | `int` | Yes | Ack receipt timestamp (ms) |
| `client_order_id` | `str` | Yes | From OrderIntent |
| `order_id` | `int` | Yes | Exchange-assigned order ID |
| `symbol` | `str` | Yes | Trading pair |
| `side` | `str` | Yes | `"BUY"` or `"SELL"` |
| `order_type` | `str` | Yes | Order type |
| `status` | `str` | Yes | Order status from exchange |
| `quantity` | `str` | Yes | Original quantity (Decimal as string) |
| `price` | `str` | Conditional | Limit price (Decimal as string) |
| `executed_qty` | `str` | Yes | Filled quantity so far |
| `avg_price` | `str` | Yes | Average fill price |
| `time_in_force` | `str` | Yes | TIF from request |
| `reduce_only` | `bool` | Yes | From request |
| `error_code` | `int` | No | Binance error code if rejected |
| `error_msg` | `str` | No | Binance error message if rejected |

### Enums

```
status: "NEW" | "PARTIALLY_FILLED" | "FILLED" | "CANCELED" | "REJECTED" | "EXPIRED"
```

### JSON Example

```json
{
  "schema_version": "1.0.0",
  "session_id": "sess_20260129_001",
  "ts": 1738180800123,
  "client_order_id": "coid_a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "order_id": 1234567890,
  "symbol": "BTCUSDT",
  "side": "BUY",
  "order_type": "LIMIT",
  "status": "NEW",
  "quantity": "0.001",
  "price": "67890.50",
  "executed_qty": "0.000",
  "avg_price": "0.00",
  "time_in_force": "GTX",
  "reduce_only": false,
  "error_code": null,
  "error_msg": null
}
```

---

## 4) FillEvent

**Purpose:** Notification of a trade fill (partial or complete).
**Producer:** UserDataStream WS (`ORDER_TRADE_UPDATE`)
**Consumer:** PositionTracker, Journal, PnL Calculator

### Dedupe Critical

**Dedupe key:** `(symbol, order_id, trade_id)` — must suppress duplicates.

### Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `schema_version` | `str` | Yes | `"1.0.0"` |
| `session_id` | `str` | Yes | Trading session ID |
| `ts` | `int` | Yes | Fill timestamp (ms) |
| `symbol` | `str` | Yes | Trading pair |
| `order_id` | `int` | Yes | Exchange order ID |
| `trade_id` | `int` | Yes | Exchange trade ID (unique per fill) |
| `client_order_id` | `str` | Yes | Client order ID |
| `side` | `str` | Yes | `"BUY"` or `"SELL"` |
| `fill_qty` | `str` | Yes | Filled quantity this event |
| `fill_price` | `str` | Yes | Fill price |
| `commission` | `str` | Yes | Commission amount |
| `commission_asset` | `str` | Yes | Commission currency (e.g., `"USDT"`) |
| `realized_pnl` | `str` | Yes | Realized PnL for this fill |
| `is_maker` | `bool` | Yes | True if maker fill |
| `position_side` | `str` | Yes | `"BOTH"`, `"LONG"`, `"SHORT"` |

### JSON Example

```json
{
  "schema_version": "1.0.0",
  "session_id": "sess_20260129_001",
  "ts": 1738180801500,
  "symbol": "BTCUSDT",
  "order_id": 1234567890,
  "trade_id": 9876543210,
  "client_order_id": "coid_a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "side": "BUY",
  "fill_qty": "0.001",
  "fill_price": "67890.50",
  "commission": "0.01358",
  "commission_asset": "USDT",
  "realized_pnl": "0.00",
  "is_maker": true,
  "position_side": "BOTH"
}
```

---

## 5) PositionSnapshot

**Purpose:** Point-in-time snapshot of position state per symbol.
**Producer:** PositionTracker
**Consumer:** RiskManager, Dashboard, Journal

### Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `schema_version` | `str` | Yes | `"1.0.0"` |
| `session_id` | `str` | Yes | Trading session ID |
| `ts` | `int` | Yes | Snapshot timestamp (ms) |
| `symbol` | `str` | Yes | Trading pair |
| `side` | `str` | Yes | `"LONG"`, `"SHORT"`, `"FLAT"` |
| `quantity` | `str` | Yes | Position size (absolute) |
| `entry_price` | `str` | Yes | Average entry price |
| `mark_price` | `str` | Yes | Current mark price |
| `unrealized_pnl` | `str` | Yes | Unrealized PnL (USD) |
| `realized_pnl_session` | `str` | Yes | Realized PnL this session |
| `leverage` | `int` | Yes | Position leverage |
| `liquidation_price` | `str` | Yes | Estimated liquidation price |
| `margin_type` | `str` | Yes | `"ISOLATED"` or `"CROSS"` |

### Enums

```
side: "LONG" | "SHORT" | "FLAT"
margin_type: "ISOLATED" | "CROSS"
```

### JSON Example

```json
{
  "schema_version": "1.0.0",
  "session_id": "sess_20260129_001",
  "ts": 1738180802000,
  "symbol": "BTCUSDT",
  "side": "LONG",
  "quantity": "0.001",
  "entry_price": "67890.50",
  "mark_price": "67920.00",
  "unrealized_pnl": "0.03",
  "realized_pnl_session": "0.00",
  "leverage": 5,
  "liquidation_price": "54312.40",
  "margin_type": "ISOLATED"
}
```

---

## 6) SessionState

**Purpose:** Trading session state machine checkpoint.
**Producer:** SessionManager
**Consumer:** OrderGovernor, RiskManager, Dashboard

### Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `schema_version` | `str` | Yes | `"1.0.0"` |
| `session_id` | `str` | Yes | Trading session ID |
| `ts` | `int` | Yes | State change timestamp (ms) |
| `state` | `str` | Yes | Current session state |
| `prev_state` | `str` | No | Previous state (for transition logging) |
| `reason` | `str` | No | Reason for state change |
| `symbols_active` | `list[str]` | Yes | Currently active symbols |
| `open_orders_count` | `int` | Yes | Number of open orders |
| `positions_count` | `int` | Yes | Number of open positions |
| `daily_pnl` | `str` | Yes | Session PnL so far (USD) |
| `daily_trades` | `int` | Yes | Number of trades this session |
| `risk_utilization` | `str` | Yes | Risk budget utilization (0.0-1.0) |

### State Machine

```
INITIALIZING → READY → ACTIVE → PAUSED → ACTIVE
                  ↓        ↓        ↓
              STOPPING → STOPPED → KILLED
```

### Enums

```
state: "INITIALIZING" | "READY" | "ACTIVE" | "PAUSED" | "STOPPING" | "STOPPED" | "KILLED"
```

### JSON Example

```json
{
  "schema_version": "1.0.0",
  "session_id": "sess_20260129_001",
  "ts": 1738180803000,
  "state": "ACTIVE",
  "prev_state": "READY",
  "reason": "all_positions_flat_startup_complete",
  "symbols_active": ["BTCUSDT", "ETHUSDT"],
  "open_orders_count": 6,
  "positions_count": 0,
  "daily_pnl": "0.00",
  "daily_trades": 0,
  "risk_utilization": "0.15"
}
```

---

## 7) RiskBreachEvent

**Purpose:** Notification of risk limit violation.
**Producer:** RiskManager
**Consumer:** SessionManager (triggers state change), AlertSink, Journal

### Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `schema_version` | `str` | Yes | `"1.0.0"` |
| `session_id` | `str` | Yes | Trading session ID |
| `ts` | `int` | Yes | Breach detection timestamp (ms) |
| `breach_id` | `str` | Yes | Unique breach identifier (UUID) |
| `breach_type` | `str` | Yes | Type of breach |
| `severity` | `str` | Yes | `"WARNING"`, `"CRITICAL"`, `"FATAL"` |
| `symbol` | `str` | No | Affected symbol (if symbol-specific) |
| `threshold` | `str` | Yes | Configured threshold value |
| `actual` | `str` | Yes | Actual value that triggered breach |
| `action_taken` | `str` | Yes | Automated action taken |
| `details` | `str` | No | Additional context |

### Enums

```
breach_type: "DAILY_LOSS_LIMIT" | "POSITION_SIZE_LIMIT" | "EXPOSURE_LIMIT" |
             "ORDER_RATE_LIMIT" | "CONSECUTIVE_LOSS" | "DRAWDOWN_LIMIT"
severity: "WARNING" | "CRITICAL" | "FATAL"
action_taken: "NONE" | "PAUSE_SYMBOL" | "PAUSE_SESSION" | "KILL_SESSION" | "FLATTEN_ALL"
```

### JSON Example

```json
{
  "schema_version": "1.0.0",
  "session_id": "sess_20260129_001",
  "ts": 1738180900000,
  "breach_id": "breach_f1e2d3c4-b5a6-7890-1234-567890abcdef",
  "breach_type": "DAILY_LOSS_LIMIT",
  "severity": "CRITICAL",
  "symbol": null,
  "threshold": "-100.00",
  "actual": "-105.50",
  "action_taken": "PAUSE_SESSION",
  "details": "Daily loss limit of $100 exceeded. Session paused pending manual review."
}
```

---

## 8) StrategyDecision

**Purpose:** Journaled output from strategy `on_tick()` for replay and audit.
**Producer:** Strategy via ScenarioRunner
**Consumer:** Journal, Replay verifier, Audit log

### Context

The StrategyDecision contract records:
1. The context snapshot at decision time (market state, position)
2. The list of orders the strategy wants to place
3. Timing information for replay verification

This enables deterministic replay verification and debugging.

### Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `schema_version` | `str` | Yes | `"1.0.0"` |
| `session_id` | `str` | Yes | Trading session ID |
| `ts` | `int` | Yes | Tick timestamp (ms) |
| `tick_seq` | `int` | Yes | Tick sequence number (0-indexed) |
| `bid` | `str` | Yes | Best bid at decision time (Decimal as string) |
| `ask` | `str` | Yes | Best ask at decision time (Decimal as string) |
| `mid` | `str` | Yes | Mid price at decision time (Decimal as string) |
| `last_trade_price` | `str` | Yes | Last trade price (Decimal as string) |
| `position_qty` | `str` | Yes | Signed position quantity (Decimal as string) |
| `position_side` | `str` | Yes | `"LONG"`, `"SHORT"`, `"FLAT"` |
| `unrealized_pnl` | `str` | Yes | Unrealized PnL (Decimal as string) |
| `realized_pnl` | `str` | Yes | Realized PnL (Decimal as string) |
| `pending_order_count` | `int` | Yes | Pending orders before decision |
| `orders` | `list[StrategyDecisionOrder]` | Yes | Orders to place (may be empty) |
| `symbol` | `str` | Yes | Trading symbol |

### StrategyDecisionOrder Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `schema_version` | `str` | Yes | `"1.0.0"` |
| `session_id` | `str` | Yes | Trading session ID |
| `side` | `str` | Yes | `"BUY"` or `"SELL"` |
| `price` | `str` | Yes | Limit price (Decimal as string) |
| `quantity` | `str` | Yes | Order quantity (Decimal as string) |
| `reason` | `str` | No | Human-readable reason |

### Dedupe Key

`(session_id, tick_seq)` — one decision per tick.

### JSON Example

```json
{
  "schema_version": "1.0.0",
  "session_id": "sim_abc123def456",
  "ts": 1706140800500,
  "tick_seq": 42,
  "bid": "42000.00",
  "ask": "42001.00",
  "mid": "42000.50",
  "last_trade_price": "42000.25",
  "position_qty": "0.001",
  "position_side": "LONG",
  "unrealized_pnl": "0.50",
  "realized_pnl": "2.30",
  "pending_order_count": 0,
  "orders": [
    {
      "schema_version": "1.0.0",
      "session_id": "sim_abc123def456",
      "side": "SELL",
      "price": "42004.20",
      "quantity": "0.001",
      "reason": "close_long"
    }
  ],
  "symbol": "BTCUSDT"
}
```

---

## 9) Roundtrip & Determinism Test Plan

This section describes the test strategy to be implemented in the next step (code implementation).

### 9.1 Test Files to Create

| File | Purpose |
|------|---------|
| `tests/trading/__init__.py` | Package marker |
| `tests/trading/test_contracts_roundtrip.py` | Roundtrip serialization tests |
| `tests/trading/test_contracts_validation.py` | Schema validation tests |
| `tests/trading/test_fill_dedupe.py` | FillEvent dedupe logic tests |

### 9.2 Roundtrip Tests (`test_contracts_roundtrip.py`)

For each contract:

```python
def test_{contract}_roundtrip():
    """Object → JSON → Object equality (Decimal-safe)."""
    original = {Contract}(...)
    json_str = original.model_dump_json()
    restored = {Contract}.model_validate_json(json_str)
    assert original == restored

def test_{contract}_requires_schema_version():
    """Reject if schema_version missing."""
    with pytest.raises(ValidationError):
        {Contract}(schema_version=None, ...)

def test_{contract}_requires_session_id():
    """Reject if session_id missing."""
    with pytest.raises(ValidationError):
        {Contract}(session_id=None, ...)

def test_{contract}_decimal_precision():
    """Decimal fields preserve precision through roundtrip."""
    original = {Contract}(price="67890.123456789", ...)
    json_str = original.model_dump_json()
    restored = {Contract}.model_validate_json(json_str)
    assert restored.price == Decimal("67890.123456789")
```

### 9.3 Validation Tests (`test_contracts_validation.py`)

```python
def test_{contract}_enum_validation():
    """Invalid enum values are rejected."""
    with pytest.raises(ValidationError):
        OrderIntent(side="INVALID", ...)

def test_{contract}_required_fields():
    """Missing required fields are rejected."""
    with pytest.raises(ValidationError):
        OrderIntent()  # Missing all required fields
```

### 9.4 Dedupe Tests (`test_fill_dedupe.py`)

```python
def test_fill_dedupe_key():
    """Dedupe key is (symbol, order_id, trade_id)."""
    fill1 = FillEvent(symbol="BTCUSDT", order_id=123, trade_id=456, ...)
    fill2 = FillEvent(symbol="BTCUSDT", order_id=123, trade_id=456, ...)
    fill3 = FillEvent(symbol="BTCUSDT", order_id=123, trade_id=457, ...)

    dedupe_set = set()
    dedupe_set.add(fill1.dedupe_key)
    dedupe_set.add(fill2.dedupe_key)  # Should not increase size
    dedupe_set.add(fill3.dedupe_key)  # Should increase size

    assert len(dedupe_set) == 2

def test_fill_dedupe_suppression():
    """Duplicate fills are suppressed by dedupe logic."""
    processor = FillProcessor()
    fill1 = FillEvent(symbol="BTCUSDT", order_id=123, trade_id=456, ...)
    fill2 = FillEvent(symbol="BTCUSDT", order_id=123, trade_id=456, ...)

    assert processor.process(fill1) == True   # First: processed
    assert processor.process(fill2) == False  # Duplicate: suppressed
```

### 9.5 Fixtures Strategy

```
tests/fixtures/trading_contracts/
├── manifest.json           # Fixture metadata + checksums
├── checksums.txt           # SHA256 of all fixture files
├── order_intent_valid.json
├── order_ack_valid.json
├── order_ack_rejected.json
├── fill_event_maker.json
├── fill_event_taker.json
├── position_snapshot_long.json
├── position_snapshot_flat.json
├── session_state_active.json
├── session_state_killed.json
├── risk_breach_warning.json
└── risk_breach_fatal.json
```

**manifest.json** format (matches v1 pattern):

```json
{
  "schema_version": "1.0.0",
  "created_at": "2026-01-29T12:00:00Z",
  "git_sha": "abc1234",
  "fixtures": {
    "order_intent_valid.json": {
      "sha256": "...",
      "contract": "OrderIntent"
    }
  }
}
```

### 9.6 Determinism Verification

```python
def test_roundtrip_determinism():
    """Two serialization runs produce identical output."""
    obj = OrderIntent(...)

    json1 = obj.model_dump_json(indent=2)
    json2 = obj.model_dump_json(indent=2)

    assert json1 == json2
    assert hashlib.sha256(json1.encode()).hexdigest() == \
           hashlib.sha256(json2.encode()).hexdigest()
```

### 9.7 CI Integration

- Add `tests/trading/` to pytest collection
- Trigger on changes to `src/cryptoscreener/trading/contracts/`
- Add to `acceptance_packet.sh` replay detection paths

---

## 10) Migration Notes

### From Float to Decimal

If migrating existing code that uses float:

1. **Parse:** `Decimal(str(float_value))` — NOT `Decimal(float_value)`
2. **Serialize:** Always serialize as string
3. **Compare:** Use `Decimal.quantize()` for tolerance comparisons

### Schema Version Upgrades

When upgrading `schema_version`:

1. Add new version to enum
2. Implement migration function
3. Update fixtures
4. Bump manifest version

---

## References

- v1 Data Contracts: `docs/03_architecture/DATA_CONTRACTS.md`
- v2 Scope Boundary: `docs/trading/01_SCOPE_BOUNDARY_SSOT.md`
- v2 Spec: `docs/trading/TRADING_SPEC.md`
- Binance Trading Limits: `docs/02_binance/BINANCE_LIMITS.md` §6
