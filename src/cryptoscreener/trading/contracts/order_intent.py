"""OrderIntent contract.

Request to place an order, generated by trading logic.
Producer: VolHarvester / OrderManager
Consumer: OrderGovernor -> Binance REST
"""

from __future__ import annotations

from decimal import Decimal  # noqa: TC003 - used at runtime in validators
from typing import Annotated

from pydantic import Field, field_validator

from cryptoscreener.trading.contracts.base import (
    TradingContractBase,
    parse_decimal,
)
from cryptoscreener.trading.contracts.types import (
    OrderPriority,
    OrderSide,
    OrderType,
    TimeInForce,
)


class OrderIntent(TradingContractBase):
    """Request to place an order.

    All monetary values use Decimal for precision.
    """

    ts: int = Field(description="Intent creation timestamp (ms)")
    client_order_id: str = Field(description="Unique client-side ID (UUID)")
    symbol: str = Field(description="Trading pair (e.g., BTCUSDT)")
    side: OrderSide = Field(description="BUY or SELL")
    order_type: OrderType = Field(description="LIMIT, MARKET, or STOP_MARKET")
    quantity: Annotated[Decimal, Field(description="Order size")] = Field()
    price: Annotated[Decimal | None, Field(description="Limit price")] = None
    time_in_force: TimeInForce = Field(description="Time in force")
    reduce_only: bool = Field(description="If true, only reduces position")
    priority: OrderPriority = Field(description="Order priority for governor")
    reason: str | None = Field(
        default=None,
        description="Human-readable intent reason",
    )

    @field_validator("quantity", mode="before")
    @classmethod
    def parse_quantity(cls, v: object) -> Decimal:
        """Parse quantity to Decimal."""
        return parse_decimal(v)

    @field_validator("price", mode="before")
    @classmethod
    def parse_price(cls, v: object) -> Decimal | None:
        """Parse price to Decimal if provided."""
        if v is None:
            return None
        return parse_decimal(v)

    @field_validator("price", mode="after")
    @classmethod
    def validate_price_for_limit(cls, v: Decimal | None, info: object) -> Decimal | None:
        """Ensure price is provided for LIMIT orders."""
        # Access other values via info.data
        data = getattr(info, "data", {})
        order_type = data.get("order_type")
        if order_type == OrderType.LIMIT and v is None:
            raise ValueError("price is required for LIMIT orders")
        return v

    @property
    def dedupe_key(self) -> tuple[str, str]:
        """Dedupe key: (session_id, client_order_id)."""
        return (self.session_id, self.client_order_id)
